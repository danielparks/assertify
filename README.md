# Assertify and Testify

This provides two convenience macros to make tests with easy to understand
failure messages from simple Rust expressions.

### `assertify!(expr)`

Generates an assertion for `expr` with a friendly failure message. If `expr` is
a binary expression, the actual value should be on the left and the expected
value should be on the right.

```rust
#[test]
fn simple_eq() {
    assertify!(1 + 2 == 0);
}
```

```
---- tests::simple_eq stdout ----
thread 'tests::simple_eq' panicked at 'failed: 1 + 2 == 0
  actual:      3
  expected: == 0
', src/lib.rs:98:9
```

This is a major improvement over the message generated by `assert_eq!`, since
the failure message shows what the failed expression was.

```rust
#[test]
fn simple_eq_traditional() {
    assert_eq!(1 + 2, 0);
}
```

```
---- tests::simple_eq_traditional stdout ----
thread 'tests::simple_eq_traditional' panicked at 'assertion failed: `(left == right)`
  left: `3`,
 right: `0`', src/lib.rs:103:9

```

### `testify!(name, expr)`

Generates a test function named `name` that asserts that `expr` is true.

```rust
testify!(concat_literals, concat("a", "b") == "ab");
```

Again, the failure messages are easy to understand:

```
---- tests::concat_literals stdout ----
thread 'tests::concat_literals' panicked at 'failed: concat("a", "b") == "aX"
  actual:      "ab"
  expected: == "aX"
', src/lib.rs:106:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```

## Compatibility

This requires at least Rust version 1.45 (released in July 2020).

## License

This project dual-licensed under the Apache 2 and MIT licenses. You may choose
to use either.

  * [Apache License, Version 2.0](LICENSE-APACHE)
  * [MIT license](LICENSE-MIT)

### Contributions

Unless you explicitly state otherwise, any contribution you submit as defined
in the Apache 2.0 license shall be dual licensed as above, without any
additional terms or conditions.
